#!/bin/bash
# BARF - Build And Run Framework
# Issue-Driven Autonomous Development based on the Ralph Playbook

set -euo pipefail

# ============================================================================
# Constants
# ============================================================================
VERSION="0.2.0"
CONFIG_FILE=".barf.yaml"
DEFAULT_ISSUES_DIR="./issues"
DEFAULT_PLANS_DIR="./plans"
DEFAULT_MAX_RETRIES=3

# Approximate token limits per model (conservative estimates)
TOKEN_LIMIT_HAIKU=180000
TOKEN_LIMIT_SONNET=180000
TOKEN_LIMIT_OPUS=180000
CHARS_PER_TOKEN=4  # Rough estimate

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# ============================================================================
# Utility Functions
# ============================================================================

log_info() {
    echo -e "${BLUE}[INFO]${NC} $1"
}

log_success() {
    echo -e "${GREEN}[OK]${NC} $1"
}

log_warn() {
    echo -e "${YELLOW}[WARN]${NC} $1"
}

log_error() {
    echo -e "${RED}[ERROR]${NC} $1" >&2
}

die() {
    log_error "$1"
    exit 1
}

# Check if a command exists
require_cmd() {
    command -v "$1" &> /dev/null || die "Required command not found: $1"
}

# ============================================================================
# Test Command Auto-Detection
# ============================================================================

# Detect the test command for the current project
detect_test_command() {
    # Check AGENTS.md first (user preference)
    if [[ -f "AGENTS.md" ]]; then
        local agents_test
        agents_test=$(grep -A1 "# Run tests" "AGENTS.md" 2>/dev/null | tail -1 | sed 's/^#[[:space:]]*//' | tr -d '\n')
        if [[ -n "$agents_test" && "$agents_test" != "#"* ]]; then
            echo "$agents_test"
            return
        fi
    fi

    # Check package.json (Node.js)
    if [[ -f "package.json" ]]; then
        if grep -q '"test"' "package.json"; then
            echo "npm test"
            return
        fi
    fi

    # Check for pytest (Python)
    if [[ -f "pytest.ini" || -f "pyproject.toml" || -f "setup.py" ]]; then
        if command -v pytest &>/dev/null; then
            echo "pytest"
            return
        elif command -v python &>/dev/null; then
            echo "python -m pytest"
            return
        fi
    fi

    # Check Cargo.toml (Rust)
    if [[ -f "Cargo.toml" ]]; then
        echo "cargo test"
        return
    fi

    # Check go.mod (Go)
    if [[ -f "go.mod" ]]; then
        echo "go test ./..."
        return
    fi

    # Check Makefile
    if [[ -f "Makefile" ]]; then
        if grep -q "^test:" "Makefile"; then
            echo "make test"
            return
        fi
    fi

    # Check for mix.exs (Elixir)
    if [[ -f "mix.exs" ]]; then
        echo "mix test"
        return
    fi

    # Check for Gemfile (Ruby)
    if [[ -f "Gemfile" ]]; then
        if grep -q "rspec" "Gemfile"; then
            echo "bundle exec rspec"
            return
        elif [[ -d "test" ]]; then
            echo "bundle exec rake test"
            return
        fi
    fi

    # Check for build.gradle (Java/Kotlin)
    if [[ -f "build.gradle" || -f "build.gradle.kts" ]]; then
        echo "./gradlew test"
        return
    fi

    # Check for pom.xml (Maven)
    if [[ -f "pom.xml" ]]; then
        echo "mvn test"
        return
    fi

    # Default: no test command found
    echo ""
}

# ============================================================================
# Context Tracking
# ============================================================================

# Estimate token count from character count
estimate_tokens() {
    local text="$1"
    local char_count=${#text}
    echo $((char_count / CHARS_PER_TOKEN))
}

# Get token limit for a model
get_token_limit() {
    local model="$1"
    case "$model" in
        haiku)
            echo $TOKEN_LIMIT_HAIKU
            ;;
        sonnet)
            echo $TOKEN_LIMIT_SONNET
            ;;
        opus)
            echo $TOKEN_LIMIT_OPUS
            ;;
        *)
            echo $TOKEN_LIMIT_SONNET
            ;;
    esac
}

# Check if we're approaching context limit
check_context_limit() {
    local content="$1"
    local model="$2"
    local threshold="${3:-0.8}"  # 80% by default

    local estimated_tokens
    estimated_tokens=$(estimate_tokens "$content")

    local limit
    limit=$(get_token_limit "$model")

    local threshold_tokens
    threshold_tokens=$(echo "$limit * $threshold" | bc 2>/dev/null || echo $((limit * 8 / 10)))

    if [[ $estimated_tokens -gt $threshold_tokens ]]; then
        return 0  # True: approaching limit
    else
        return 1  # False: still have room
    fi
}

# Parse Claude CLI output for context errors
detect_context_error() {
    local output="$1"

    # Check for various context limit indicators
    if echo "$output" | grep -qiE "context.*(limit|window|length|exceeded|full)"; then
        return 0
    fi
    if echo "$output" | grep -qiE "token.*(limit|exceeded|maximum)"; then
        return 0
    fi
    if echo "$output" | grep -qiE "maximum.*(context|length|tokens)"; then
        return 0
    fi
    if echo "$output" | grep -qiE "too (long|large|many tokens)"; then
        return 0
    fi
    if echo "$output" | grep -qiE "input.*truncated"; then
        return 0
    fi

    return 1  # No context error detected
}

# ============================================================================
# Config Parsing (simple YAML subset)
# ============================================================================

# Get a value from the config file
# Usage: config_get "source.type" "default_value"
config_get() {
    local key="$1"
    local default="${2:-}"

    if [[ ! -f "$CONFIG_FILE" ]]; then
        echo "$default"
        return
    fi

    # Simple YAML parsing - handles nested keys like "source.type"
    local value
    value=$(parse_yaml_key "$CONFIG_FILE" "$key")

    if [[ -n "$value" ]]; then
        echo "$value"
    else
        echo "$default"
    fi
}

# Parse a specific key from YAML file
parse_yaml_key() {
    local file="$1"
    local key="$2"

    # Split key by dots
    IFS='.' read -ra parts <<< "$key"

    local indent=0
    local current_indent=0
    local in_section=true
    local part_index=0
    local target_part="${parts[$part_index]}"

    while IFS= read -r line || [[ -n "$line" ]]; do
        # Skip comments and empty lines
        [[ "$line" =~ ^[[:space:]]*# ]] && continue
        [[ -z "${line// }" ]] && continue

        # Calculate indentation
        local stripped="${line#"${line%%[![:space:]]*}"}"
        current_indent=$(( (${#line} - ${#stripped}) / 2 ))

        # Check if we're still in the right section
        if [[ $current_indent -lt $indent ]] && [[ $part_index -gt 0 ]]; then
            in_section=false
        fi

        if $in_section; then
            # Look for the current target key
            if [[ "$line" =~ ^[[:space:]]*${target_part}:[[:space:]]*(.*) ]]; then
                local value="${BASH_REMATCH[1]}"

                # Move to next part of the key
                ((part_index++))

                if [[ $part_index -ge ${#parts[@]} ]]; then
                    # We found the final key
                    # Remove quotes and comments
                    value="${value%%#*}"
                    value="${value%"${value##*[![:space:]]}"}"
                    value="${value#\"}"
                    value="${value%\"}"
                    value="${value#\'}"
                    value="${value%\'}"
                    echo "$value"
                    return
                else
                    # Go deeper
                    target_part="${parts[$part_index]}"
                    indent=$((current_indent + 1))
                fi
            fi
        fi
    done < "$file"
}

# ============================================================================
# Plugin System
# ============================================================================

# Get the plugin script path based on source type
get_plugin_path() {
    local source_type
    source_type=$(config_get "source.type" "local")

    case "$source_type" in
        local)
            echo "$(dirname "$0")/plugins/local.sh"
            ;;
        github)
            echo "$(dirname "$0")/plugins/github.sh"
            ;;
        gitlab)
            echo "$(dirname "$0")/plugins/gitlab.sh"
            ;;
        custom)
            config_get "source.plugin"
            ;;
        *)
            die "Unknown source type: $source_type"
            ;;
    esac
}

# Call a plugin command
# Usage: plugin_call /fetch issue-name
plugin_call() {
    local cmd="$1"
    shift

    local plugin_path
    plugin_path=$(get_plugin_path)

    if [[ ! -f "$plugin_path" ]]; then
        die "Plugin not found: $plugin_path"
    fi

    if [[ ! -x "$plugin_path" ]]; then
        chmod +x "$plugin_path"
    fi

    "$plugin_path" "$cmd" "$@"
}

# ============================================================================
# Model Selection
# ============================================================================

# Select the appropriate model for a task type
# Usage: select_model "fast|default|complex"
select_model() {
    local task_type="${1:-default}"

    case "$task_type" in
        fast)
            config_get "models.fast" "haiku"
            ;;
        complex)
            config_get "models.complex" "opus"
            ;;
        *)
            config_get "models.default" "sonnet"
            ;;
    esac
}

# Map model name to Claude CLI model flag
get_model_flag() {
    local model="$1"

    case "$model" in
        haiku)
            echo "--model claude-3-5-haiku-latest"
            ;;
        sonnet)
            echo "--model claude-sonnet-4-20250514"
            ;;
        opus)
            echo "--model claude-opus-4-20250514"
            ;;
        *)
            echo "--model claude-sonnet-4-20250514"
            ;;
    esac
}

# ============================================================================
# Init Command
# ============================================================================

cmd_init() {
    log_info "Initializing BARF in current directory..."

    # Create config file
    if [[ ! -f "$CONFIG_FILE" ]]; then
        cat > "$CONFIG_FILE" << 'EOF'
# BARF Configuration

source:
  type: local
  path: ./issues

issues:
  reference: filename

commands:
  fetch: /fetch
  update: /update
  comment: /comment
  context: /context
  status: /status
  list: /list
  create: /create
  link: /link

plans:
  path: ./plans

split:
  enabled: true
  max_retries: 3
  pattern: "{issue}-part{n}"

models:
  fast: haiku
  default: sonnet
  complex: opus

build:
  commit_format: "feat({issue}): {task}"
  run_tests: true

interview:
  auto_update: true
  use_comments: true

audit:
  output: ./AUDIT_REPORT.md
EOF
        log_success "Created $CONFIG_FILE"
    else
        log_warn "$CONFIG_FILE already exists, skipping"
    fi

    # Create directories
    local issues_dir
    issues_dir=$(config_get "source.path" "$DEFAULT_ISSUES_DIR")

    local plans_dir
    plans_dir=$(config_get "plans.path" "$DEFAULT_PLANS_DIR")

    mkdir -p "$issues_dir" && log_success "Created $issues_dir/"
    mkdir -p "$plans_dir" && log_success "Created $plans_dir/"
    mkdir -p "$(dirname "$0")/plugins" && log_success "Created plugins/"

    # Create AGENTS.md if it doesn't exist
    if [[ ! -f "AGENTS.md" ]]; then
        cat > "AGENTS.md" << 'EOF'
# AGENTS.md - Operational Guide

This file contains operational information for autonomous agents working on this codebase.

## Project Overview

<!-- Describe your project here -->

## Development Commands

```bash
# Install dependencies
# npm install

# Run tests
# npm test

# Build
# npm run build

# Lint
# npm run lint
```

## Architecture Notes

<!-- Describe key architectural decisions -->

## Common Patterns

<!-- Document patterns used in this codebase -->

## Known Issues

<!-- Document known issues or gotchas -->
EOF
        log_success "Created AGENTS.md"
    else
        log_warn "AGENTS.md already exists, skipping"
    fi

    # Create prompt files
    create_prompt_files

    # Create default local plugin
    create_local_plugin

    log_success "BARF initialized successfully!"
    echo ""
    echo "Next steps:"
    echo "  1. Edit .barf.yaml to configure your project"
    echo "  2. Edit AGENTS.md with your project details"
    echo "  3. Create issues in $issues_dir/"
    echo "  4. Run: barf interview <issue>"
}

# ============================================================================
# Prompt Files Creation
# ============================================================================

create_prompt_files() {
    # PROMPT_interview.md
    if [[ ! -f "PROMPT_interview.md" ]]; then
        cat > "PROMPT_interview.md" << 'PROMPT_EOF'
# Interview Mode Instructions

You are analyzing an issue to identify ambiguities and missing information.

## Your Task

1. Read the issue content carefully
2. Identify any ambiguities:
   - Unclear acceptance criteria
   - Missing technical constraints
   - Undefined edge cases
   - Implementation approach decisions needed
3. Ask clarifying questions using the AskUserQuestion tool
4. Update the issue with clarifications

## Guidelines

- Be thorough but not pedantic
- Focus on information needed for implementation
- Group related questions together
- Provide context for why each question matters

## Output Format

For each ambiguity found:
1. Quote the relevant part of the issue
2. Explain why it's ambiguous
3. Ask a specific clarifying question
4. Suggest options if applicable

After all clarifications:
- Summarize the clarifications
- Update the issue with the new information
PROMPT_EOF
        log_success "Created PROMPT_interview.md"
    fi

    # PROMPT_plan.md
    if [[ ! -f "PROMPT_plan.md" ]]; then
        cat > "PROMPT_plan.md" << 'PROMPT_EOF'
# Planning Mode Instructions

You are creating a detailed implementation plan from an issue.

## Your Task

1. Read the issue requirements thoroughly
2. Study the existing codebase using parallel subagents
3. Create a step-by-step implementation plan
4. Save the plan to the plans directory

## Plan Structure

```markdown
# Implementation Plan for {issue}

## Issue Summary
Brief description of what needs to be done

## Acceptance Criteria
- List each criterion from the issue
- Map to specific line numbers in the issue

## Implementation Tasks

### Task 1: {title}
**Requirements:**
- Which issue requirements this addresses (with line refs)

**Implementation:**
1. Specific step
2. Specific step
3. Specific step

**Files affected:**
- path/to/file.ts (new file | modify | delete)
- path/to/other.ts:123-145 (specific lines)

**Validation:**
- How to verify this task is complete
- Specific test cases

**Risks:**
- Potential issues or blockers

### Task 2: {title}
...
```

## Guidelines

- Be exhaustive - cover all requirements
- Be specific - include file paths and line numbers
- Be practical - order tasks by dependencies
- Be cautious - identify risks early

## Context Limit Handling

If you detect that the issue is too large:
1. Create a partial plan with completed tasks
2. Document which requirements are not yet planned
3. Recommend how to split the issue
4. Save progress before context runs out
PROMPT_EOF
        log_success "Created PROMPT_plan.md"
    fi

    # PROMPT_build.md
    if [[ ! -f "PROMPT_build.md" ]]; then
        cat > "PROMPT_build.md" << 'PROMPT_EOF'
# Building Mode Instructions

You are implementing code based on an existing plan.

## Your Task

1. Read the plan file for this issue
2. Select the most important incomplete task
3. Implement it completely
4. Run tests to verify
5. Commit if successful
6. Update the plan to mark task complete

## Guidelines

- Never assume - always search the codebase first
- Use parallel subagents to explore code
- Follow existing patterns in the codebase
- Run tests after each change (backpressure)
- Make atomic commits for each task

## When Stuck

If you cannot complete a task:
1. Document what you've tried
2. Explain the blocker
3. Create progress notes file
4. Recommend next steps

Progress notes format:
```markdown
# Progress Notes for {issue}

## Current State
- [x] Completed tasks
- [ ] Incomplete tasks

## Current Task
What you were working on

## How We Got Here
Step by step history

## The Problem
What's blocking progress

## What Was Tried
- Attempt 1: approach - result
- Attempt 2: approach - result

## Recommendations
Options to resolve the blocker
```

## Context Limit Handling

If context is filling up:
1. Save all progress immediately
2. Create progress notes
3. Document remaining tasks
4. Recommend issue split if needed
PROMPT_EOF
        log_success "Created PROMPT_build.md"
    fi

    # PROMPT_audit.md
    if [[ ! -f "PROMPT_audit.md" ]]; then
        cat > "PROMPT_audit.md" << 'PROMPT_EOF'
# Audit Mode Instructions

You are performing a comprehensive quality audit of the codebase.

## Your Task

1. Analyze the entire codebase
2. Check for issues across multiple dimensions
3. Create a prioritized report

## Audit Dimensions

### Code Quality
- Code style consistency
- Error handling
- Performance issues
- Security vulnerabilities
- Dead code

### Issue Compliance
- Are all accepted issues fully implemented?
- Do implementations match requirements?
- Are there undocumented features?

### Test Coverage
- Are critical paths tested?
- Are edge cases covered?
- Are tests meaningful or just coverage padding?

### Technical Debt
- Outdated dependencies
- TODO/FIXME comments
- Workarounds that need proper fixes
- Documentation gaps

### Consistency
- Naming conventions
- File organization
- API patterns
- Error message formats

## Report Format

```markdown
# Audit Report

Generated: {date}

## Summary
- Critical: X issues
- High: X issues
- Medium: X issues
- Low: X issues

## Critical Issues
### {title}
- **Location:** file:line
- **Description:** What's wrong
- **Impact:** Why it matters
- **Recommendation:** How to fix

## High Priority
...

## Medium Priority
...

## Low Priority
...

## Recommendations
Prioritized list of improvements
```

## Guidelines

- Be objective and specific
- Provide actionable recommendations
- Include file paths and line numbers
- Prioritize by impact and effort
PROMPT_EOF
        log_success "Created PROMPT_audit.md"
    fi
}

# ============================================================================
# Local Plugin Creation
# ============================================================================

create_local_plugin() {
    local plugin_dir="$(dirname "$0")/plugins"
    local plugin_path="$plugin_dir/local.sh"

    mkdir -p "$plugin_dir"

    if [[ ! -f "$plugin_path" ]]; then
        cat > "$plugin_path" << 'PLUGIN_EOF'
#!/bin/bash
# Local Markdown Issue Plugin for BARF

set -euo pipefail

# Get issues directory from config or use default
get_issues_dir() {
    local config_file=".barf.yaml"
    if [[ -f "$config_file" ]]; then
        local path
        path=$(grep -A1 "^source:" "$config_file" | grep "path:" | sed 's/.*path:[[:space:]]*//' | tr -d '"' | tr -d "'")
        echo "${path:-./issues}"
    else
        echo "./issues"
    fi
}

ISSUES_DIR=$(get_issues_dir)

case "${1:-}" in
    /fetch)
        # Fetch issue content
        issue="${2:-}"
        [[ -z "$issue" ]] && { echo "Usage: /fetch <issue>"; exit 1; }

        # Try with and without .md extension
        if [[ -f "$ISSUES_DIR/$issue.md" ]]; then
            cat "$ISSUES_DIR/$issue.md"
        elif [[ -f "$ISSUES_DIR/$issue" ]]; then
            cat "$ISSUES_DIR/$issue"
        else
            echo "Issue not found: $issue" >&2
            exit 1
        fi
        ;;

    /update)
        # Update issue content (reads from stdin)
        issue="${2:-}"
        [[ -z "$issue" ]] && { echo "Usage: /update <issue>"; exit 1; }

        if [[ -f "$ISSUES_DIR/$issue.md" ]]; then
            cat > "$ISSUES_DIR/$issue.md"
        elif [[ -f "$ISSUES_DIR/$issue" ]]; then
            cat > "$ISSUES_DIR/$issue"
        else
            # Create new file with .md extension
            cat > "$ISSUES_DIR/$issue.md"
        fi
        echo "Issue updated: $issue"
        ;;

    /comment)
        # Add comment to issue
        issue="${2:-}"
        comment="${3:-}"
        [[ -z "$issue" ]] && { echo "Usage: /comment <issue> <text>"; exit 1; }

        local file
        if [[ -f "$ISSUES_DIR/$issue.md" ]]; then
            file="$ISSUES_DIR/$issue.md"
        elif [[ -f "$ISSUES_DIR/$issue" ]]; then
            file="$ISSUES_DIR/$issue"
        else
            echo "Issue not found: $issue" >&2
            exit 1
        fi

        # Append comment with timestamp
        {
            echo ""
            echo "---"
            echo "**Comment** ($(date '+%Y-%m-%d %H:%M')):"
            echo "$comment"
        } >> "$file"
        echo "Comment added to: $issue"
        ;;

    /context)
        # Get full context (same as fetch for local files)
        issue="${2:-}"
        [[ -z "$issue" ]] && { echo "Usage: /context <issue>"; exit 1; }

        "$0" /fetch "$issue"
        ;;

    /status)
        # Get or set issue status (stored as YAML frontmatter)
        issue="${2:-}"
        new_status="${3:-}"
        [[ -z "$issue" ]] && { echo "Usage: /status <issue> [status]"; exit 1; }

        local file
        if [[ -f "$ISSUES_DIR/$issue.md" ]]; then
            file="$ISSUES_DIR/$issue.md"
        elif [[ -f "$ISSUES_DIR/$issue" ]]; then
            file="$ISSUES_DIR/$issue"
        else
            echo "Issue not found: $issue" >&2
            exit 1
        fi

        if [[ -z "$new_status" ]]; then
            # Get status from frontmatter
            if head -1 "$file" | grep -q "^---"; then
                sed -n '2,/^---$/p' "$file" | grep "^status:" | sed 's/status:[[:space:]]*//'
            else
                echo "open"
            fi
        else
            # Set status in frontmatter
            if head -1 "$file" | grep -q "^---"; then
                # Update existing frontmatter
                sed -i "s/^status:.*/status: $new_status/" "$file"
            else
                # Add frontmatter
                local content
                content=$(cat "$file")
                {
                    echo "---"
                    echo "status: $new_status"
                    echo "---"
                    echo "$content"
                } > "$file"
            fi
            echo "Status set to: $new_status"
        fi
        ;;

    /list)
        # List all issues
        if [[ -d "$ISSUES_DIR" ]]; then
            find "$ISSUES_DIR" -name "*.md" -type f | while read -r file; do
                basename "$file" .md
            done
        fi
        ;;

    /create)
        # Create new issue
        title="${2:-}"
        body="${3:-}"
        [[ -z "$title" ]] && { echo "Usage: /create <title> [body]"; exit 1; }

        # Sanitize title for filename
        local filename
        filename=$(echo "$title" | tr '[:upper:]' '[:lower:]' | tr ' ' '-' | tr -cd '[:alnum:]-')

        mkdir -p "$ISSUES_DIR"

        {
            echo "# $title"
            echo ""
            if [[ -n "$body" ]]; then
                echo "$body"
            fi
        } > "$ISSUES_DIR/$filename.md"

        echo "$filename"
        ;;

    /link)
        # Link child issue to parent
        child="${2:-}"
        parent="${3:-}"
        [[ -z "$child" || -z "$parent" ]] && { echo "Usage: /link <child> <parent>"; exit 1; }

        "$0" /comment "$child" "Parent issue: $parent"
        "$0" /comment "$parent" "Sub-issue: $child"
        echo "Linked $child to $parent"
        ;;

    *)
        echo "Unknown command: ${1:-}"
        echo "Available commands: /fetch, /update, /comment, /context, /status, /list, /create, /link"
        exit 1
        ;;
esac
PLUGIN_EOF
        chmod +x "$plugin_path"
        log_success "Created plugins/local.sh"
    fi
}

# ============================================================================
# Interview Command
# ============================================================================

cmd_interview() {
    local issue="${1:-}"

    [[ -z "$issue" ]] && die "Usage: barf interview <issue>"

    require_cmd claude

    log_info "Starting interview for: $issue"

    # Fetch issue content
    local issue_content
    issue_content=$(plugin_call /fetch "$issue") || die "Failed to fetch issue: $issue"

    # Select model for interview (default is good enough)
    local model
    model=$(select_model "default")
    local model_flag
    model_flag=$(get_model_flag "$model")

    # Read interview prompt
    local prompt_file="PROMPT_interview.md"
    [[ ! -f "$prompt_file" ]] && die "Interview prompt not found: $prompt_file"

    local prompt
    prompt=$(cat "$prompt_file")

    # Prepare the full prompt with issue content
    local full_prompt="$prompt

## Issue Content

$issue_content

## Instructions

Analyze this issue and identify any ambiguities or missing information. Ask clarifying questions as needed."

    # Run Claude
    log_info "Analyzing issue with Claude ($model)..."

    # shellcheck disable=SC2086
    claude $model_flag --dangerously-skip-permissions -p "$full_prompt"

    log_success "Interview complete for: $issue"
}

# ============================================================================
# Plan Command
# ============================================================================

cmd_plan() {
    local issue="${1:-}"
    local max_iterations="${2:-0}"

    [[ -z "$issue" ]] && die "Usage: barf plan <issue> [max_iterations]"

    require_cmd claude

    log_info "Starting planning for: $issue"

    # Fetch issue content
    local issue_content
    issue_content=$(plugin_call /fetch "$issue") || die "Failed to fetch issue: $issue"

    # Get plans directory
    local plans_dir
    plans_dir=$(config_get "plans.path" "$DEFAULT_PLANS_DIR")
    mkdir -p "$plans_dir"

    local plan_file="$plans_dir/${issue}-plan.md"

    # Select model for planning (complex for better reasoning)
    local model
    model=$(select_model "complex")
    local model_flag
    model_flag=$(get_model_flag "$model")

    # Read planning prompt
    local prompt_file="PROMPT_plan.md"
    [[ ! -f "$prompt_file" ]] && die "Planning prompt not found: $prompt_file"

    local prompt
    prompt=$(cat "$prompt_file")

    # Prepare the full prompt
    local full_prompt="$prompt

## Issue Content

$issue_content

## Instructions

Create a detailed implementation plan for this issue. Save the plan to: $plan_file

If the issue is too large for a single plan:
1. Create a partial plan with what you can cover
2. Document which parts need separate planning
3. Recommend splitting into these sub-issues

## Existing Codebase

Use the Task tool with Explore subagent to study the codebase structure and patterns before planning."

    local iteration=1
    local split_enabled
    split_enabled=$(config_get "split.enabled" "true")
    local max_retries
    max_retries=$(config_get "split.max_retries" "$DEFAULT_MAX_RETRIES")

    while true; do
        log_info "Planning Iteration $iteration..."

        # Check max iterations
        if [[ $max_iterations -gt 0 && $iteration -gt $max_iterations ]]; then
            log_warn "Max iterations ($max_iterations) reached"
            break
        fi

        # Run Claude
        local output
        # shellcheck disable=SC2086
        if output=$(claude $model_flag --dangerously-skip-permissions -p "$full_prompt" 2>&1); then
            # Check if plan file was created
            if [[ -f "$plan_file" ]]; then
                log_success "Plan generated: $plan_file"
                break
            else
                log_warn "Plan file not created, Claude output:"
                echo "$output"
            fi
        else
            # Check for context limit error using improved detection
            if detect_context_error "$output"; then
                if [[ "$split_enabled" == "true" ]]; then
                    log_warn "Context limit reached - triggering auto-split"
                    handle_auto_split "$issue" "plan"
                    break
                else
                    die "Context limit reached and auto-split is disabled"
                fi
            else
                log_error "Planning failed: $output"
            fi
        fi

        ((iteration++))

        # Check retry limit
        if [[ $iteration -gt $max_retries ]]; then
            log_warn "Max retries ($max_retries) reached"
            if [[ "$split_enabled" == "true" ]]; then
                handle_auto_split "$issue" "plan"
            fi
            break
        fi
    done
}

# ============================================================================
# Build Command
# ============================================================================

cmd_build() {
    local issue="${1:-}"
    local max_iterations="${2:-0}"

    [[ -z "$issue" ]] && die "Usage: barf build <issue> [max_iterations]"

    require_cmd claude

    log_info "Starting build for: $issue"

    # Get plans directory
    local plans_dir
    plans_dir=$(config_get "plans.path" "$DEFAULT_PLANS_DIR")

    local plan_file="$plans_dir/${issue}-plan.md"
    local progress_file="$plans_dir/${issue}-progress.md"

    # Check if plan exists
    [[ ! -f "$plan_file" ]] && die "Plan not found: $plan_file (run 'barf plan $issue' first)"

    # Select model for building (default for most tasks)
    local model
    model=$(select_model "default")
    local model_flag
    model_flag=$(get_model_flag "$model")

    # Read build prompt
    local prompt_file="PROMPT_build.md"
    [[ ! -f "$prompt_file" ]] && die "Build prompt not found: $prompt_file"

    local prompt
    prompt=$(cat "$prompt_file")

    # Get commit format
    local commit_format
    commit_format=$(config_get "build.commit_format" "feat({issue}): {task}")

    # Detect test command
    local test_command
    test_command=$(config_get "build.test_command" "")
    if [[ -z "$test_command" ]]; then
        test_command=$(detect_test_command)
        if [[ -n "$test_command" ]]; then
            log_info "Detected test command: $test_command"
        fi
    fi

    local iteration=1
    local stuck_count=0
    local split_enabled
    split_enabled=$(config_get "split.enabled" "true")
    local max_retries
    max_retries=$(config_get "split.max_retries" "$DEFAULT_MAX_RETRIES")

    while true; do
        log_info "Building Iteration $iteration..."

        # Check max iterations
        if [[ $max_iterations -gt 0 && $iteration -gt $max_iterations ]]; then
            log_warn "Max iterations ($max_iterations) reached"
            break
        fi

        # Read current plan
        local plan_content
        plan_content=$(cat "$plan_file")

        # Check if all tasks are complete
        if ! echo "$plan_content" | grep -q "^\[ \]"; then
            log_success "All tasks complete!"
            break
        fi

        # Check context limit before sending
        local full_context="$prompt

$plan_content

$(if [[ -f "$progress_file" ]]; then cat "$progress_file"; fi)"

        if check_context_limit "$full_context" "$model" "0.7"; then
            log_warn "Context is getting large - consider splitting issue"
        fi

        # Prepare the full prompt
        local full_prompt="$prompt

## Plan Content

$plan_content

## Progress Notes

$(if [[ -f "$progress_file" ]]; then cat "$progress_file"; else echo "No progress notes yet."; fi)

## Test Command

$(if [[ -n "$test_command" ]]; then echo "Run tests with: $test_command"; else echo "No test command detected - check AGENTS.md or add to .barf.yaml"; fi)

## Instructions

1. Select the most important incomplete task (marked with [ ])
2. Implement it completely
3. Run tests to verify: ${test_command:-'(configure in AGENTS.md or .barf.yaml)'}
4. If tests pass, commit with format: $commit_format
5. Update the plan file to mark the task as [x]
6. If stuck, create progress notes and exit

Issue name for commits: $issue"

        # Run Claude
        local output
        # shellcheck disable=SC2086
        if output=$(claude $model_flag --dangerously-skip-permissions -p "$full_prompt" 2>&1); then
            # Check for stuck indicator
            if echo "$output" | grep -qi "stuck\|blocked\|cannot\|unable"; then
                ((stuck_count++))
                log_warn "Agent reports being stuck (attempt $stuck_count/$max_retries)"

                if [[ $stuck_count -ge $max_retries ]]; then
                    if [[ "$split_enabled" == "true" ]]; then
                        log_warn "Max stuck attempts reached - triggering auto-split"
                        handle_auto_split "$issue" "build"
                        break
                    else
                        log_error "Max stuck attempts reached and auto-split is disabled"
                        break
                    fi
                fi

                log_info "Retrying with fresh context..."
            else
                # Reset stuck count on progress
                stuck_count=0
            fi
        else
            # Check for context limit error using improved detection
            if detect_context_error "$output"; then
                if [[ "$split_enabled" == "true" ]]; then
                    log_warn "Context limit reached - triggering auto-split"
                    handle_auto_split "$issue" "build"
                    break
                else
                    die "Context limit reached and auto-split is disabled"
                fi
            else
                log_error "Build iteration failed: $output"
            fi
        fi

        ((iteration++))
    done
}

# ============================================================================
# Resume Command
# ============================================================================

cmd_resume() {
    local issue="${1:-}"
    local max_iterations="${2:-0}"

    [[ -z "$issue" ]] && die "Usage: barf resume <issue> [max_iterations]"

    require_cmd claude

    # Get plans directory
    local plans_dir
    plans_dir=$(config_get "plans.path" "$DEFAULT_PLANS_DIR")

    local plan_file="$plans_dir/${issue}-plan.md"
    local progress_file="$plans_dir/${issue}-progress.md"

    # Check what exists to determine how to resume
    if [[ -f "$progress_file" ]]; then
        log_info "Found progress notes for: $issue"
        log_info "Resuming from saved progress..."

        # Check if there are sub-issues to work on
        local sub_issues
        sub_issues=$(grep -E "^- [a-zA-Z0-9_-]+:" "$progress_file" 2>/dev/null | sed 's/^- \([^:]*\):.*/\1/' || echo "")

        if [[ -n "$sub_issues" ]]; then
            log_info "Found sub-issues from previous split:"
            echo "$sub_issues" | while read -r sub; do
                [[ -n "$sub" ]] && echo "  - $sub"
            done
            echo ""

            # Work on first incomplete sub-issue
            echo "$sub_issues" | while read -r sub_issue; do
                [[ -z "$sub_issue" ]] && continue

                local sub_plan="$plans_dir/${sub_issue}-plan.md"
                local sub_status
                sub_status=$(plugin_call /status "$sub_issue" 2>/dev/null || echo "open")

                if [[ "$sub_status" != "closed" && "$sub_status" != "done" && "$sub_status" != "completed" ]]; then
                    if [[ ! -f "$sub_plan" ]]; then
                        log_info "Planning sub-issue: $sub_issue"
                        cmd_plan "$sub_issue" "$max_iterations"
                    fi

                    log_info "Building sub-issue: $sub_issue"
                    cmd_build "$sub_issue" "$max_iterations"
                    return
                fi
            done

            log_success "All sub-issues appear complete!"
            log_info "Marking parent issue as complete..."
            plugin_call /status "$issue" "completed" 2>/dev/null || true
            return
        fi
    fi

    # No sub-issues, check for plan
    if [[ -f "$plan_file" ]]; then
        # Check if there are incomplete tasks
        if grep -q "^\[ \]" "$plan_file"; then
            log_info "Found incomplete tasks in plan, resuming build..."
            cmd_build "$issue" "$max_iterations"
        else
            log_success "All tasks in plan are complete!"
            plugin_call /status "$issue" "completed" 2>/dev/null || true
        fi
    else
        # No plan exists, start from planning
        log_info "No plan found, starting from planning phase..."
        cmd_plan "$issue" "$max_iterations"

        if [[ -f "$plan_file" ]]; then
            log_info "Plan created, starting build..."
            cmd_build "$issue" "$max_iterations"
        fi
    fi
}

# ============================================================================
# List Command
# ============================================================================

cmd_list() {
    local filter="${1:-}"

    log_info "Issues:"
    echo ""

    # Get list from plugin
    local issues
    issues=$(plugin_call /list 2>/dev/null) || die "Failed to list issues"

    if [[ -z "$issues" ]]; then
        echo "  No issues found."
        return
    fi

    # Get plans directory for status check
    local plans_dir
    plans_dir=$(config_get "plans.path" "$DEFAULT_PLANS_DIR")

    echo "$issues" | while read -r issue_line; do
        [[ -z "$issue_line" ]] && continue

        # Extract issue name (may include status from plugin)
        local issue_name
        issue_name=$(echo "$issue_line" | sed 's/ (.*//')

        # Check for plan and progress
        local has_plan=""
        local has_progress=""
        local task_status=""

        if [[ -f "$plans_dir/${issue_name}-plan.md" ]]; then
            has_plan="[plan]"
            # Count tasks
            local total_tasks
            local done_tasks
            total_tasks=$(grep -c "^\[.\]" "$plans_dir/${issue_name}-plan.md" 2>/dev/null || echo "0")
            done_tasks=$(grep -c "^\[x\]" "$plans_dir/${issue_name}-plan.md" 2>/dev/null || echo "0")
            if [[ $total_tasks -gt 0 ]]; then
                task_status="($done_tasks/$total_tasks)"
            fi
        fi

        if [[ -f "$plans_dir/${issue_name}-progress.md" ]]; then
            has_progress="[progress]"
        fi

        # Apply filter if specified
        case "$filter" in
            --planned|planned)
                [[ -z "$has_plan" ]] && continue
                ;;
            --in-progress|in-progress)
                [[ -z "$has_progress" && -z "$has_plan" ]] && continue
                ;;
            --open|open)
                echo "$issue_line" | grep -qi "closed\|done\|completed" && continue
                ;;
            "")
                # No filter
                ;;
        esac

        printf "  %-30s %s %s %s\n" "$issue_line" "$has_plan" "$has_progress" "$task_status"
    done
}

# ============================================================================
# Status Command
# ============================================================================

cmd_status() {
    local issue="${1:-}"
    local new_status="${2:-}"

    if [[ -z "$issue" ]]; then
        # Show overall status summary
        log_info "BARF Status Summary"
        echo ""

        local plans_dir
        plans_dir=$(config_get "plans.path" "$DEFAULT_PLANS_DIR")

        local issues_dir
        issues_dir=$(config_get "source.path" "$DEFAULT_ISSUES_DIR")

        # Count issues
        local total_issues=0
        local planned_issues=0
        local in_progress=0
        local completed_issues=0

        if [[ -d "$issues_dir" ]]; then
            total_issues=$(find "$issues_dir" -maxdepth 1 -name "*.md" -type f 2>/dev/null | wc -l)
        fi

        if [[ -d "$plans_dir" ]]; then
            planned_issues=$(find "$plans_dir" -name "*-plan.md" -type f 2>/dev/null | wc -l)
            in_progress=$(find "$plans_dir" -name "*-progress.md" -type f 2>/dev/null | wc -l)
        fi

        echo "  Total issues:     $total_issues"
        echo "  With plans:       $planned_issues"
        echo "  In progress:      $in_progress"
        echo ""

        # Show test command
        local test_cmd
        test_cmd=$(detect_test_command)
        if [[ -n "$test_cmd" ]]; then
            echo "  Test command:     $test_cmd"
        else
            echo "  Test command:     (not detected)"
        fi

        # Show source type
        local source_type
        source_type=$(config_get "source.type" "local")
        echo "  Issue source:     $source_type"

        return
    fi

    # Get or set status for specific issue
    if [[ -z "$new_status" ]]; then
        # Get status
        local status
        status=$(plugin_call /status "$issue" 2>/dev/null) || status="unknown"

        local plans_dir
        plans_dir=$(config_get "plans.path" "$DEFAULT_PLANS_DIR")

        echo "Issue: $issue"
        echo "Status: $status"

        # Show plan status if exists
        if [[ -f "$plans_dir/${issue}-plan.md" ]]; then
            local total_tasks
            local done_tasks
            total_tasks=$(grep -c "^\[.\]" "$plans_dir/${issue}-plan.md" 2>/dev/null || echo "0")
            done_tasks=$(grep -c "^\[x\]" "$plans_dir/${issue}-plan.md" 2>/dev/null || echo "0")
            echo "Tasks: $done_tasks/$total_tasks complete"

            # Show incomplete tasks
            local incomplete
            incomplete=$(grep "^\[ \]" "$plans_dir/${issue}-plan.md" 2>/dev/null | head -5)
            if [[ -n "$incomplete" ]]; then
                echo ""
                echo "Next tasks:"
                echo "$incomplete" | while read -r task; do
                    echo "  $task"
                done
            fi
        fi

        # Show progress notes if exists
        if [[ -f "$plans_dir/${issue}-progress.md" ]]; then
            echo ""
            echo "Progress notes: $plans_dir/${issue}-progress.md"

            # Check for blockers
            local problem
            problem=$(sed -n '/^## The Problem/,/^##/p' "$plans_dir/${issue}-progress.md" 2>/dev/null | head -5)
            if [[ -n "$problem" ]]; then
                echo ""
                echo "Current blocker:"
                echo "$problem" | tail -n +2 | head -3 | while read -r line; do
                    echo "  $line"
                done
            fi
        fi
    else
        # Set status
        plugin_call /status "$issue" "$new_status"
        log_success "Status updated: $issue -> $new_status"
    fi
}

# ============================================================================
# Audit Command
# ============================================================================

cmd_audit() {
    require_cmd claude

    log_info "Starting codebase audit..."

    # Get audit output file
    local audit_output
    audit_output=$(config_get "audit.output" "./AUDIT_REPORT.md")

    # Select model for audit (complex for thorough analysis)
    local model
    model=$(select_model "complex")
    local model_flag
    model_flag=$(get_model_flag "$model")

    # Read audit prompt
    local prompt_file="PROMPT_audit.md"
    [[ ! -f "$prompt_file" ]] && die "Audit prompt not found: $prompt_file"

    local prompt
    prompt=$(cat "$prompt_file")

    # Read AGENTS.md for context
    local agents_content=""
    if [[ -f "AGENTS.md" ]]; then
        agents_content=$(cat "AGENTS.md")
    fi

    # Prepare the full prompt
    local full_prompt="$prompt

## AGENTS.md Content

$agents_content

## Instructions

Perform a comprehensive audit of this codebase. Save the report to: $audit_output

Use the Task tool with Explore subagent to analyze the codebase thoroughly."

    log_info "Analyzing codebase with Claude ($model)..."

    # shellcheck disable=SC2086
    claude $model_flag --dangerously-skip-permissions -p "$full_prompt"

    if [[ -f "$audit_output" ]]; then
        log_success "Audit complete: $audit_output"
    else
        log_warn "Audit complete but report file not found"
    fi
}

# ============================================================================
# Auto-Split Handler
# ============================================================================

handle_auto_split() {
    local issue="$1"
    local mode="$2"  # plan or build

    log_info "Handling auto-split for: $issue"

    local plans_dir
    plans_dir=$(config_get "plans.path" "$DEFAULT_PLANS_DIR")

    local progress_file="$plans_dir/${issue}-progress.md"
    local split_pattern
    split_pattern=$(config_get "split.pattern" "{issue}-part{n}")

    # Create progress notes if they don't exist
    if [[ ! -f "$progress_file" ]]; then
        cat > "$progress_file" << EOF
# Progress Notes for $issue

## Status
Auto-split triggered during $mode mode

## Reason
Context limit reached or stuck after max retries

## Created Sub-Issues
<!-- BARF will add sub-issues here -->

## Recommendations
1. Review the sub-issues created
2. Run barf plan/build on each sub-issue
3. Mark parent issue as complete when all sub-issues are done
EOF
    fi

    # Use Claude to analyze and recommend splits
    local model
    model=$(select_model "fast")
    local model_flag
    model_flag=$(get_model_flag "$model")

    # Fetch issue content
    local issue_content
    issue_content=$(plugin_call /fetch "$issue" 2>/dev/null) || issue_content=""

    # Get existing plan if any
    local plan_content=""
    local plan_file="$plans_dir/${issue}-plan.md"
    if [[ -f "$plan_file" ]]; then
        plan_content=$(cat "$plan_file")
    fi

    local split_prompt="Analyze this issue and recommend how to split it into 2-4 smaller sub-issues.

Issue content:
$issue_content

Existing plan (if any):
$plan_content

Provide a brief list of recommended sub-issues with titles and scope. Format:
1. {title} - {brief scope description}
2. {title} - {brief scope description}
..."

    log_info "Analyzing issue for split recommendations..."

    local recommendations
    # shellcheck disable=SC2086
    recommendations=$(claude $model_flag --dangerously-skip-permissions -p "$split_prompt" 2>/dev/null) || recommendations="Manual split recommended"

    # Create sub-issues based on pattern
    local n=1
    echo "$recommendations" | grep -E "^[0-9]+\." | while read -r line; do
        local title
        title=$(echo "$line" | sed 's/^[0-9]*\.[[:space:]]*//' | cut -d'-' -f1 | xargs)

        if [[ -n "$title" ]]; then
            local sub_issue
            sub_issue="${split_pattern//\{issue\}/$issue}"
            sub_issue="${sub_issue//\{n\}/$n}"

            # Create sub-issue
            local new_issue
            new_issue=$(plugin_call /create "$title" "Parent: $issue

$line")

            if [[ -n "$new_issue" ]]; then
                # Link to parent
                plugin_call /link "$new_issue" "$issue" 2>/dev/null || true

                log_success "Created sub-issue: $new_issue"

                # Update progress file
                echo "- $new_issue: $title" >> "$progress_file"
            fi

            ((n++))
        fi
    done

    log_info "Split recommendations saved to: $progress_file"
    echo ""
    echo "Next steps:"
    echo "  1. Review sub-issues created"
    echo "  2. Run 'barf plan <sub-issue>' for each"
    echo "  3. Run 'barf build <sub-issue>' for each"
}

# ============================================================================
# Help & Version
# ============================================================================

show_help() {
    cat << 'EOF'
BARF - Build And Run Framework

Usage: barf <command> [options]

Commands:
  init                    Initialize BARF in current directory
  interview <issue>       Analyze issue and ask clarifying questions
  plan <issue> [max]      Generate implementation plan (max iterations)
  build <issue> [max]     Build from plan (max iterations)
  resume <issue> [max]    Resume work on an issue (auto-detects state)
  audit                   Perform codebase quality audit
  list [filter]           List all issues (filters: --open, --planned, --in-progress)
  status [issue] [state]  Show status summary or get/set issue status

Options:
  -h, --help              Show this help
  -v, --version           Show version

Examples:
  barf init
  barf interview auth
  barf plan auth 5
  barf build auth 20
  barf resume auth           # Continue where you left off
  barf list                  # Show all issues
  barf list --open           # Show open issues
  barf status                # Show summary
  barf status auth           # Show issue status
  barf status auth done      # Mark issue done
  barf audit

Configuration:
  Create .barf.yaml in your project root to customize behavior.
  See .barf.yaml.example for all options.

For more information: https://github.com/brewpirate/barf
EOF
}

show_version() {
    echo "BARF v$VERSION"
}

# ============================================================================
# Main Entry Point
# ============================================================================

main() {
    local cmd="${1:-}"
    shift || true

    case "$cmd" in
        init)
            cmd_init "$@"
            ;;
        interview)
            cmd_interview "$@"
            ;;
        plan)
            cmd_plan "$@"
            ;;
        build)
            cmd_build "$@"
            ;;
        resume)
            cmd_resume "$@"
            ;;
        audit)
            cmd_audit "$@"
            ;;
        list|ls)
            cmd_list "$@"
            ;;
        status|st)
            cmd_status "$@"
            ;;
        -h|--help|help)
            show_help
            ;;
        -v|--version|version)
            show_version
            ;;
        "")
            show_help
            ;;
        *)
            die "Unknown command: $cmd (use 'barf --help' for usage)"
            ;;
    esac
}

main "$@"
