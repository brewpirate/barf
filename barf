#!/bin/bash
# BARF - Build And Run Framework
# Issue-Driven Autonomous Development based on the Ralph Playbook

set -euo pipefail

# ============================================================================
# Constants
# ============================================================================
VERSION="0.1.0"
CONFIG_FILE=".barf.yaml"
DEFAULT_ISSUES_DIR="./issues"
DEFAULT_PLANS_DIR="./plans"
DEFAULT_MAX_RETRIES=3

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# ============================================================================
# Utility Functions
# ============================================================================

log_info() {
    echo -e "${BLUE}[INFO]${NC} $1"
}

log_success() {
    echo -e "${GREEN}[OK]${NC} $1"
}

log_warn() {
    echo -e "${YELLOW}[WARN]${NC} $1"
}

log_error() {
    echo -e "${RED}[ERROR]${NC} $1" >&2
}

die() {
    log_error "$1"
    exit 1
}

# Check if a command exists
require_cmd() {
    command -v "$1" &> /dev/null || die "Required command not found: $1"
}

# ============================================================================
# Config Parsing (simple YAML subset)
# ============================================================================

# Get a value from the config file
# Usage: config_get "source.type" "default_value"
config_get() {
    local key="$1"
    local default="${2:-}"

    if [[ ! -f "$CONFIG_FILE" ]]; then
        echo "$default"
        return
    fi

    # Simple YAML parsing - handles nested keys like "source.type"
    local value
    value=$(parse_yaml_key "$CONFIG_FILE" "$key")

    if [[ -n "$value" ]]; then
        echo "$value"
    else
        echo "$default"
    fi
}

# Parse a specific key from YAML file
parse_yaml_key() {
    local file="$1"
    local key="$2"

    # Split key by dots
    IFS='.' read -ra parts <<< "$key"

    local indent=0
    local current_indent=0
    local in_section=true
    local part_index=0
    local target_part="${parts[$part_index]}"

    while IFS= read -r line || [[ -n "$line" ]]; do
        # Skip comments and empty lines
        [[ "$line" =~ ^[[:space:]]*# ]] && continue
        [[ -z "${line// }" ]] && continue

        # Calculate indentation
        local stripped="${line#"${line%%[![:space:]]*}"}"
        current_indent=$(( (${#line} - ${#stripped}) / 2 ))

        # Check if we're still in the right section
        if [[ $current_indent -lt $indent ]] && [[ $part_index -gt 0 ]]; then
            in_section=false
        fi

        if $in_section; then
            # Look for the current target key
            if [[ "$line" =~ ^[[:space:]]*${target_part}:[[:space:]]*(.*) ]]; then
                local value="${BASH_REMATCH[1]}"

                # Move to next part of the key
                ((part_index++))

                if [[ $part_index -ge ${#parts[@]} ]]; then
                    # We found the final key
                    # Remove quotes and comments
                    value="${value%%#*}"
                    value="${value%"${value##*[![:space:]]}"}"
                    value="${value#\"}"
                    value="${value%\"}"
                    value="${value#\'}"
                    value="${value%\'}"
                    echo "$value"
                    return
                else
                    # Go deeper
                    target_part="${parts[$part_index]}"
                    indent=$((current_indent + 1))
                fi
            fi
        fi
    done < "$file"
}

# ============================================================================
# Plugin System
# ============================================================================

# Get the plugin script path based on source type
get_plugin_path() {
    local source_type
    source_type=$(config_get "source.type" "local")

    case "$source_type" in
        local)
            echo "$(dirname "$0")/plugins/local.sh"
            ;;
        github)
            echo "$(dirname "$0")/plugins/github.sh"
            ;;
        gitlab)
            echo "$(dirname "$0")/plugins/gitlab.sh"
            ;;
        custom)
            config_get "source.plugin"
            ;;
        *)
            die "Unknown source type: $source_type"
            ;;
    esac
}

# Call a plugin command
# Usage: plugin_call /fetch issue-name
plugin_call() {
    local cmd="$1"
    shift

    local plugin_path
    plugin_path=$(get_plugin_path)

    if [[ ! -f "$plugin_path" ]]; then
        die "Plugin not found: $plugin_path"
    fi

    if [[ ! -x "$plugin_path" ]]; then
        chmod +x "$plugin_path"
    fi

    "$plugin_path" "$cmd" "$@"
}

# ============================================================================
# Model Selection
# ============================================================================

# Select the appropriate model for a task type
# Usage: select_model "fast|default|complex"
select_model() {
    local task_type="${1:-default}"

    case "$task_type" in
        fast)
            config_get "models.fast" "haiku"
            ;;
        complex)
            config_get "models.complex" "opus"
            ;;
        *)
            config_get "models.default" "sonnet"
            ;;
    esac
}

# Map model name to Claude CLI model flag
get_model_flag() {
    local model="$1"

    case "$model" in
        haiku)
            echo "--model claude-3-5-haiku-latest"
            ;;
        sonnet)
            echo "--model claude-sonnet-4-20250514"
            ;;
        opus)
            echo "--model claude-opus-4-20250514"
            ;;
        *)
            echo "--model claude-sonnet-4-20250514"
            ;;
    esac
}

# ============================================================================
# Init Command
# ============================================================================

cmd_init() {
    log_info "Initializing BARF in current directory..."

    # Create config file
    if [[ ! -f "$CONFIG_FILE" ]]; then
        cat > "$CONFIG_FILE" << 'EOF'
# BARF Configuration

source:
  type: local
  path: ./issues

issues:
  reference: filename

commands:
  fetch: /fetch
  update: /update
  comment: /comment
  context: /context
  status: /status
  list: /list
  create: /create
  link: /link

plans:
  path: ./plans

split:
  enabled: true
  max_retries: 3
  pattern: "{issue}-part{n}"

models:
  fast: haiku
  default: sonnet
  complex: opus

build:
  commit_format: "feat({issue}): {task}"
  run_tests: true

interview:
  auto_update: true
  use_comments: true

audit:
  output: ./AUDIT_REPORT.md
EOF
        log_success "Created $CONFIG_FILE"
    else
        log_warn "$CONFIG_FILE already exists, skipping"
    fi

    # Create directories
    local issues_dir
    issues_dir=$(config_get "source.path" "$DEFAULT_ISSUES_DIR")

    local plans_dir
    plans_dir=$(config_get "plans.path" "$DEFAULT_PLANS_DIR")

    mkdir -p "$issues_dir" && log_success "Created $issues_dir/"
    mkdir -p "$plans_dir" && log_success "Created $plans_dir/"
    mkdir -p "$(dirname "$0")/plugins" && log_success "Created plugins/"

    # Create AGENTS.md if it doesn't exist
    if [[ ! -f "AGENTS.md" ]]; then
        cat > "AGENTS.md" << 'EOF'
# AGENTS.md - Operational Guide

This file contains operational information for autonomous agents working on this codebase.

## Project Overview

<!-- Describe your project here -->

## Development Commands

```bash
# Install dependencies
# npm install

# Run tests
# npm test

# Build
# npm run build

# Lint
# npm run lint
```

## Architecture Notes

<!-- Describe key architectural decisions -->

## Common Patterns

<!-- Document patterns used in this codebase -->

## Known Issues

<!-- Document known issues or gotchas -->
EOF
        log_success "Created AGENTS.md"
    else
        log_warn "AGENTS.md already exists, skipping"
    fi

    # Create prompt files
    create_prompt_files

    # Create default local plugin
    create_local_plugin

    log_success "BARF initialized successfully!"
    echo ""
    echo "Next steps:"
    echo "  1. Edit .barf.yaml to configure your project"
    echo "  2. Edit AGENTS.md with your project details"
    echo "  3. Create issues in $issues_dir/"
    echo "  4. Run: barf interview <issue>"
}

# ============================================================================
# Prompt Files Creation
# ============================================================================

create_prompt_files() {
    # PROMPT_interview.md
    if [[ ! -f "PROMPT_interview.md" ]]; then
        cat > "PROMPT_interview.md" << 'PROMPT_EOF'
# Interview Mode Instructions

You are analyzing an issue to identify ambiguities and missing information.

## Your Task

1. Read the issue content carefully
2. Identify any ambiguities:
   - Unclear acceptance criteria
   - Missing technical constraints
   - Undefined edge cases
   - Implementation approach decisions needed
3. Ask clarifying questions using the AskUserQuestion tool
4. Update the issue with clarifications

## Guidelines

- Be thorough but not pedantic
- Focus on information needed for implementation
- Group related questions together
- Provide context for why each question matters

## Output Format

For each ambiguity found:
1. Quote the relevant part of the issue
2. Explain why it's ambiguous
3. Ask a specific clarifying question
4. Suggest options if applicable

After all clarifications:
- Summarize the clarifications
- Update the issue with the new information
PROMPT_EOF
        log_success "Created PROMPT_interview.md"
    fi

    # PROMPT_plan.md
    if [[ ! -f "PROMPT_plan.md" ]]; then
        cat > "PROMPT_plan.md" << 'PROMPT_EOF'
# Planning Mode Instructions

You are creating a detailed implementation plan from an issue.

## Your Task

1. Read the issue requirements thoroughly
2. Study the existing codebase using parallel subagents
3. Create a step-by-step implementation plan
4. Save the plan to the plans directory

## Plan Structure

```markdown
# Implementation Plan for {issue}

## Issue Summary
Brief description of what needs to be done

## Acceptance Criteria
- List each criterion from the issue
- Map to specific line numbers in the issue

## Implementation Tasks

### Task 1: {title}
**Requirements:**
- Which issue requirements this addresses (with line refs)

**Implementation:**
1. Specific step
2. Specific step
3. Specific step

**Files affected:**
- path/to/file.ts (new file | modify | delete)
- path/to/other.ts:123-145 (specific lines)

**Validation:**
- How to verify this task is complete
- Specific test cases

**Risks:**
- Potential issues or blockers

### Task 2: {title}
...
```

## Guidelines

- Be exhaustive - cover all requirements
- Be specific - include file paths and line numbers
- Be practical - order tasks by dependencies
- Be cautious - identify risks early

## Context Limit Handling

If you detect that the issue is too large:
1. Create a partial plan with completed tasks
2. Document which requirements are not yet planned
3. Recommend how to split the issue
4. Save progress before context runs out
PROMPT_EOF
        log_success "Created PROMPT_plan.md"
    fi

    # PROMPT_build.md
    if [[ ! -f "PROMPT_build.md" ]]; then
        cat > "PROMPT_build.md" << 'PROMPT_EOF'
# Building Mode Instructions

You are implementing code based on an existing plan.

## Your Task

1. Read the plan file for this issue
2. Select the most important incomplete task
3. Implement it completely
4. Run tests to verify
5. Commit if successful
6. Update the plan to mark task complete

## Guidelines

- Never assume - always search the codebase first
- Use parallel subagents to explore code
- Follow existing patterns in the codebase
- Run tests after each change (backpressure)
- Make atomic commits for each task

## When Stuck

If you cannot complete a task:
1. Document what you've tried
2. Explain the blocker
3. Create progress notes file
4. Recommend next steps

Progress notes format:
```markdown
# Progress Notes for {issue}

## Current State
- [x] Completed tasks
- [ ] Incomplete tasks

## Current Task
What you were working on

## How We Got Here
Step by step history

## The Problem
What's blocking progress

## What Was Tried
- Attempt 1: approach - result
- Attempt 2: approach - result

## Recommendations
Options to resolve the blocker
```

## Context Limit Handling

If context is filling up:
1. Save all progress immediately
2. Create progress notes
3. Document remaining tasks
4. Recommend issue split if needed
PROMPT_EOF
        log_success "Created PROMPT_build.md"
    fi

    # PROMPT_audit.md
    if [[ ! -f "PROMPT_audit.md" ]]; then
        cat > "PROMPT_audit.md" << 'PROMPT_EOF'
# Audit Mode Instructions

You are performing a comprehensive quality audit of the codebase.

## Your Task

1. Analyze the entire codebase
2. Check for issues across multiple dimensions
3. Create a prioritized report

## Audit Dimensions

### Code Quality
- Code style consistency
- Error handling
- Performance issues
- Security vulnerabilities
- Dead code

### Issue Compliance
- Are all accepted issues fully implemented?
- Do implementations match requirements?
- Are there undocumented features?

### Test Coverage
- Are critical paths tested?
- Are edge cases covered?
- Are tests meaningful or just coverage padding?

### Technical Debt
- Outdated dependencies
- TODO/FIXME comments
- Workarounds that need proper fixes
- Documentation gaps

### Consistency
- Naming conventions
- File organization
- API patterns
- Error message formats

## Report Format

```markdown
# Audit Report

Generated: {date}

## Summary
- Critical: X issues
- High: X issues
- Medium: X issues
- Low: X issues

## Critical Issues
### {title}
- **Location:** file:line
- **Description:** What's wrong
- **Impact:** Why it matters
- **Recommendation:** How to fix

## High Priority
...

## Medium Priority
...

## Low Priority
...

## Recommendations
Prioritized list of improvements
```

## Guidelines

- Be objective and specific
- Provide actionable recommendations
- Include file paths and line numbers
- Prioritize by impact and effort
PROMPT_EOF
        log_success "Created PROMPT_audit.md"
    fi
}

# ============================================================================
# Local Plugin Creation
# ============================================================================

create_local_plugin() {
    local plugin_dir="$(dirname "$0")/plugins"
    local plugin_path="$plugin_dir/local.sh"

    mkdir -p "$plugin_dir"

    if [[ ! -f "$plugin_path" ]]; then
        cat > "$plugin_path" << 'PLUGIN_EOF'
#!/bin/bash
# Local Markdown Issue Plugin for BARF

set -euo pipefail

# Get issues directory from config or use default
get_issues_dir() {
    local config_file=".barf.yaml"
    if [[ -f "$config_file" ]]; then
        local path
        path=$(grep -A1 "^source:" "$config_file" | grep "path:" | sed 's/.*path:[[:space:]]*//' | tr -d '"' | tr -d "'")
        echo "${path:-./issues}"
    else
        echo "./issues"
    fi
}

ISSUES_DIR=$(get_issues_dir)

case "${1:-}" in
    /fetch)
        # Fetch issue content
        issue="${2:-}"
        [[ -z "$issue" ]] && { echo "Usage: /fetch <issue>"; exit 1; }

        # Try with and without .md extension
        if [[ -f "$ISSUES_DIR/$issue.md" ]]; then
            cat "$ISSUES_DIR/$issue.md"
        elif [[ -f "$ISSUES_DIR/$issue" ]]; then
            cat "$ISSUES_DIR/$issue"
        else
            echo "Issue not found: $issue" >&2
            exit 1
        fi
        ;;

    /update)
        # Update issue content (reads from stdin)
        issue="${2:-}"
        [[ -z "$issue" ]] && { echo "Usage: /update <issue>"; exit 1; }

        if [[ -f "$ISSUES_DIR/$issue.md" ]]; then
            cat > "$ISSUES_DIR/$issue.md"
        elif [[ -f "$ISSUES_DIR/$issue" ]]; then
            cat > "$ISSUES_DIR/$issue"
        else
            # Create new file with .md extension
            cat > "$ISSUES_DIR/$issue.md"
        fi
        echo "Issue updated: $issue"
        ;;

    /comment)
        # Add comment to issue
        issue="${2:-}"
        comment="${3:-}"
        [[ -z "$issue" ]] && { echo "Usage: /comment <issue> <text>"; exit 1; }

        local file
        if [[ -f "$ISSUES_DIR/$issue.md" ]]; then
            file="$ISSUES_DIR/$issue.md"
        elif [[ -f "$ISSUES_DIR/$issue" ]]; then
            file="$ISSUES_DIR/$issue"
        else
            echo "Issue not found: $issue" >&2
            exit 1
        fi

        # Append comment with timestamp
        {
            echo ""
            echo "---"
            echo "**Comment** ($(date '+%Y-%m-%d %H:%M')):"
            echo "$comment"
        } >> "$file"
        echo "Comment added to: $issue"
        ;;

    /context)
        # Get full context (same as fetch for local files)
        issue="${2:-}"
        [[ -z "$issue" ]] && { echo "Usage: /context <issue>"; exit 1; }

        "$0" /fetch "$issue"
        ;;

    /status)
        # Get or set issue status (stored as YAML frontmatter)
        issue="${2:-}"
        new_status="${3:-}"
        [[ -z "$issue" ]] && { echo "Usage: /status <issue> [status]"; exit 1; }

        local file
        if [[ -f "$ISSUES_DIR/$issue.md" ]]; then
            file="$ISSUES_DIR/$issue.md"
        elif [[ -f "$ISSUES_DIR/$issue" ]]; then
            file="$ISSUES_DIR/$issue"
        else
            echo "Issue not found: $issue" >&2
            exit 1
        fi

        if [[ -z "$new_status" ]]; then
            # Get status from frontmatter
            if head -1 "$file" | grep -q "^---"; then
                sed -n '2,/^---$/p' "$file" | grep "^status:" | sed 's/status:[[:space:]]*//'
            else
                echo "open"
            fi
        else
            # Set status in frontmatter
            if head -1 "$file" | grep -q "^---"; then
                # Update existing frontmatter
                sed -i "s/^status:.*/status: $new_status/" "$file"
            else
                # Add frontmatter
                local content
                content=$(cat "$file")
                {
                    echo "---"
                    echo "status: $new_status"
                    echo "---"
                    echo "$content"
                } > "$file"
            fi
            echo "Status set to: $new_status"
        fi
        ;;

    /list)
        # List all issues
        if [[ -d "$ISSUES_DIR" ]]; then
            find "$ISSUES_DIR" -name "*.md" -type f | while read -r file; do
                basename "$file" .md
            done
        fi
        ;;

    /create)
        # Create new issue
        title="${2:-}"
        body="${3:-}"
        [[ -z "$title" ]] && { echo "Usage: /create <title> [body]"; exit 1; }

        # Sanitize title for filename
        local filename
        filename=$(echo "$title" | tr '[:upper:]' '[:lower:]' | tr ' ' '-' | tr -cd '[:alnum:]-')

        mkdir -p "$ISSUES_DIR"

        {
            echo "# $title"
            echo ""
            if [[ -n "$body" ]]; then
                echo "$body"
            fi
        } > "$ISSUES_DIR/$filename.md"

        echo "$filename"
        ;;

    /link)
        # Link child issue to parent
        child="${2:-}"
        parent="${3:-}"
        [[ -z "$child" || -z "$parent" ]] && { echo "Usage: /link <child> <parent>"; exit 1; }

        "$0" /comment "$child" "Parent issue: $parent"
        "$0" /comment "$parent" "Sub-issue: $child"
        echo "Linked $child to $parent"
        ;;

    *)
        echo "Unknown command: ${1:-}"
        echo "Available commands: /fetch, /update, /comment, /context, /status, /list, /create, /link"
        exit 1
        ;;
esac
PLUGIN_EOF
        chmod +x "$plugin_path"
        log_success "Created plugins/local.sh"
    fi
}

# ============================================================================
# Interview Command
# ============================================================================

cmd_interview() {
    local issue="${1:-}"

    [[ -z "$issue" ]] && die "Usage: barf interview <issue>"

    require_cmd claude

    log_info "Starting interview for: $issue"

    # Fetch issue content
    local issue_content
    issue_content=$(plugin_call /fetch "$issue") || die "Failed to fetch issue: $issue"

    # Select model for interview (default is good enough)
    local model
    model=$(select_model "default")
    local model_flag
    model_flag=$(get_model_flag "$model")

    # Read interview prompt
    local prompt_file="PROMPT_interview.md"
    [[ ! -f "$prompt_file" ]] && die "Interview prompt not found: $prompt_file"

    local prompt
    prompt=$(cat "$prompt_file")

    # Prepare the full prompt with issue content
    local full_prompt="$prompt

## Issue Content

$issue_content

## Instructions

Analyze this issue and identify any ambiguities or missing information. Ask clarifying questions as needed."

    # Run Claude
    log_info "Analyzing issue with Claude ($model)..."

    # shellcheck disable=SC2086
    claude $model_flag --dangerously-skip-permissions -p "$full_prompt"

    log_success "Interview complete for: $issue"
}

# ============================================================================
# Plan Command
# ============================================================================

cmd_plan() {
    local issue="${1:-}"
    local max_iterations="${2:-0}"

    [[ -z "$issue" ]] && die "Usage: barf plan <issue> [max_iterations]"

    require_cmd claude

    log_info "Starting planning for: $issue"

    # Fetch issue content
    local issue_content
    issue_content=$(plugin_call /fetch "$issue") || die "Failed to fetch issue: $issue"

    # Get plans directory
    local plans_dir
    plans_dir=$(config_get "plans.path" "$DEFAULT_PLANS_DIR")
    mkdir -p "$plans_dir"

    local plan_file="$plans_dir/${issue}-plan.md"

    # Select model for planning (complex for better reasoning)
    local model
    model=$(select_model "complex")
    local model_flag
    model_flag=$(get_model_flag "$model")

    # Read planning prompt
    local prompt_file="PROMPT_plan.md"
    [[ ! -f "$prompt_file" ]] && die "Planning prompt not found: $prompt_file"

    local prompt
    prompt=$(cat "$prompt_file")

    # Prepare the full prompt
    local full_prompt="$prompt

## Issue Content

$issue_content

## Instructions

Create a detailed implementation plan for this issue. Save the plan to: $plan_file

If the issue is too large for a single plan:
1. Create a partial plan with what you can cover
2. Document which parts need separate planning
3. Recommend splitting into these sub-issues

## Existing Codebase

Use the Task tool with Explore subagent to study the codebase structure and patterns before planning."

    local iteration=1
    local split_enabled
    split_enabled=$(config_get "split.enabled" "true")
    local max_retries
    max_retries=$(config_get "split.max_retries" "$DEFAULT_MAX_RETRIES")

    while true; do
        log_info "Planning Iteration $iteration..."

        # Check max iterations
        if [[ $max_iterations -gt 0 && $iteration -gt $max_iterations ]]; then
            log_warn "Max iterations ($max_iterations) reached"
            break
        fi

        # Run Claude
        local output
        # shellcheck disable=SC2086
        if output=$(claude $model_flag --dangerously-skip-permissions -p "$full_prompt" 2>&1); then
            # Check if plan file was created
            if [[ -f "$plan_file" ]]; then
                log_success "Plan generated: $plan_file"
                break
            else
                log_warn "Plan file not created, Claude output:"
                echo "$output"
            fi
        else
            # Check for context limit error
            if echo "$output" | grep -qi "context\|token\|limit"; then
                if [[ "$split_enabled" == "true" ]]; then
                    log_warn "Context limit reached - triggering auto-split"
                    handle_auto_split "$issue" "plan"
                    break
                else
                    die "Context limit reached and auto-split is disabled"
                fi
            else
                log_error "Planning failed: $output"
            fi
        fi

        ((iteration++))

        # Check retry limit
        if [[ $iteration -gt $max_retries ]]; then
            log_warn "Max retries ($max_retries) reached"
            if [[ "$split_enabled" == "true" ]]; then
                handle_auto_split "$issue" "plan"
            fi
            break
        fi
    done
}

# ============================================================================
# Build Command
# ============================================================================

cmd_build() {
    local issue="${1:-}"
    local max_iterations="${2:-0}"

    [[ -z "$issue" ]] && die "Usage: barf build <issue> [max_iterations]"

    require_cmd claude

    log_info "Starting build for: $issue"

    # Get plans directory
    local plans_dir
    plans_dir=$(config_get "plans.path" "$DEFAULT_PLANS_DIR")

    local plan_file="$plans_dir/${issue}-plan.md"
    local progress_file="$plans_dir/${issue}-progress.md"

    # Check if plan exists
    [[ ! -f "$plan_file" ]] && die "Plan not found: $plan_file (run 'barf plan $issue' first)"

    # Select model for building (default for most tasks)
    local model
    model=$(select_model "default")
    local model_flag
    model_flag=$(get_model_flag "$model")

    # Read build prompt
    local prompt_file="PROMPT_build.md"
    [[ ! -f "$prompt_file" ]] && die "Build prompt not found: $prompt_file"

    local prompt
    prompt=$(cat "$prompt_file")

    # Get commit format
    local commit_format
    commit_format=$(config_get "build.commit_format" "feat({issue}): {task}")

    local iteration=1
    local stuck_count=0
    local split_enabled
    split_enabled=$(config_get "split.enabled" "true")
    local max_retries
    max_retries=$(config_get "split.max_retries" "$DEFAULT_MAX_RETRIES")

    while true; do
        log_info "Building Iteration $iteration..."

        # Check max iterations
        if [[ $max_iterations -gt 0 && $iteration -gt $max_iterations ]]; then
            log_warn "Max iterations ($max_iterations) reached"
            break
        fi

        # Read current plan
        local plan_content
        plan_content=$(cat "$plan_file")

        # Check if all tasks are complete
        if ! echo "$plan_content" | grep -q "^\[ \]"; then
            log_success "All tasks complete!"
            break
        fi

        # Prepare the full prompt
        local full_prompt="$prompt

## Plan Content

$plan_content

## Progress Notes

$(if [[ -f "$progress_file" ]]; then cat "$progress_file"; else echo "No progress notes yet."; fi)

## Instructions

1. Select the most important incomplete task (marked with [ ])
2. Implement it completely
3. Run tests to verify
4. If tests pass, commit with format: $commit_format
5. Update the plan file to mark the task as [x]
6. If stuck, create progress notes and exit

Issue name for commits: $issue"

        # Run Claude
        local output
        # shellcheck disable=SC2086
        if output=$(claude $model_flag --dangerously-skip-permissions -p "$full_prompt" 2>&1); then
            # Check for stuck indicator
            if echo "$output" | grep -qi "stuck\|blocked\|cannot\|unable"; then
                ((stuck_count++))
                log_warn "Agent reports being stuck (attempt $stuck_count/$max_retries)"

                if [[ $stuck_count -ge $max_retries ]]; then
                    if [[ "$split_enabled" == "true" ]]; then
                        log_warn "Max stuck attempts reached - triggering auto-split"
                        handle_auto_split "$issue" "build"
                        break
                    else
                        log_error "Max stuck attempts reached and auto-split is disabled"
                        break
                    fi
                fi

                log_info "Retrying with fresh context..."
            else
                # Reset stuck count on progress
                stuck_count=0
            fi
        else
            # Check for context limit error
            if echo "$output" | grep -qi "context\|token\|limit"; then
                if [[ "$split_enabled" == "true" ]]; then
                    log_warn "Context limit reached - triggering auto-split"
                    handle_auto_split "$issue" "build"
                    break
                else
                    die "Context limit reached and auto-split is disabled"
                fi
            else
                log_error "Build iteration failed: $output"
            fi
        fi

        ((iteration++))
    done
}

# ============================================================================
# Audit Command
# ============================================================================

cmd_audit() {
    require_cmd claude

    log_info "Starting codebase audit..."

    # Get audit output file
    local audit_output
    audit_output=$(config_get "audit.output" "./AUDIT_REPORT.md")

    # Select model for audit (complex for thorough analysis)
    local model
    model=$(select_model "complex")
    local model_flag
    model_flag=$(get_model_flag "$model")

    # Read audit prompt
    local prompt_file="PROMPT_audit.md"
    [[ ! -f "$prompt_file" ]] && die "Audit prompt not found: $prompt_file"

    local prompt
    prompt=$(cat "$prompt_file")

    # Read AGENTS.md for context
    local agents_content=""
    if [[ -f "AGENTS.md" ]]; then
        agents_content=$(cat "AGENTS.md")
    fi

    # Prepare the full prompt
    local full_prompt="$prompt

## AGENTS.md Content

$agents_content

## Instructions

Perform a comprehensive audit of this codebase. Save the report to: $audit_output

Use the Task tool with Explore subagent to analyze the codebase thoroughly."

    log_info "Analyzing codebase with Claude ($model)..."

    # shellcheck disable=SC2086
    claude $model_flag --dangerously-skip-permissions -p "$full_prompt"

    if [[ -f "$audit_output" ]]; then
        log_success "Audit complete: $audit_output"
    else
        log_warn "Audit complete but report file not found"
    fi
}

# ============================================================================
# Auto-Split Handler
# ============================================================================

handle_auto_split() {
    local issue="$1"
    local mode="$2"  # plan or build

    log_info "Handling auto-split for: $issue"

    local plans_dir
    plans_dir=$(config_get "plans.path" "$DEFAULT_PLANS_DIR")

    local progress_file="$plans_dir/${issue}-progress.md"
    local split_pattern
    split_pattern=$(config_get "split.pattern" "{issue}-part{n}")

    # Create progress notes if they don't exist
    if [[ ! -f "$progress_file" ]]; then
        cat > "$progress_file" << EOF
# Progress Notes for $issue

## Status
Auto-split triggered during $mode mode

## Reason
Context limit reached or stuck after max retries

## Created Sub-Issues
<!-- BARF will add sub-issues here -->

## Recommendations
1. Review the sub-issues created
2. Run barf plan/build on each sub-issue
3. Mark parent issue as complete when all sub-issues are done
EOF
    fi

    # Use Claude to analyze and recommend splits
    local model
    model=$(select_model "fast")
    local model_flag
    model_flag=$(get_model_flag "$model")

    # Fetch issue content
    local issue_content
    issue_content=$(plugin_call /fetch "$issue" 2>/dev/null) || issue_content=""

    # Get existing plan if any
    local plan_content=""
    local plan_file="$plans_dir/${issue}-plan.md"
    if [[ -f "$plan_file" ]]; then
        plan_content=$(cat "$plan_file")
    fi

    local split_prompt="Analyze this issue and recommend how to split it into 2-4 smaller sub-issues.

Issue content:
$issue_content

Existing plan (if any):
$plan_content

Provide a brief list of recommended sub-issues with titles and scope. Format:
1. {title} - {brief scope description}
2. {title} - {brief scope description}
..."

    log_info "Analyzing issue for split recommendations..."

    local recommendations
    # shellcheck disable=SC2086
    recommendations=$(claude $model_flag --dangerously-skip-permissions -p "$split_prompt" 2>/dev/null) || recommendations="Manual split recommended"

    # Create sub-issues based on pattern
    local n=1
    echo "$recommendations" | grep -E "^[0-9]+\." | while read -r line; do
        local title
        title=$(echo "$line" | sed 's/^[0-9]*\.[[:space:]]*//' | cut -d'-' -f1 | xargs)

        if [[ -n "$title" ]]; then
            local sub_issue
            sub_issue="${split_pattern//\{issue\}/$issue}"
            sub_issue="${sub_issue//\{n\}/$n}"

            # Create sub-issue
            local new_issue
            new_issue=$(plugin_call /create "$title" "Parent: $issue

$line")

            if [[ -n "$new_issue" ]]; then
                # Link to parent
                plugin_call /link "$new_issue" "$issue" 2>/dev/null || true

                log_success "Created sub-issue: $new_issue"

                # Update progress file
                echo "- $new_issue: $title" >> "$progress_file"
            fi

            ((n++))
        fi
    done

    log_info "Split recommendations saved to: $progress_file"
    echo ""
    echo "Next steps:"
    echo "  1. Review sub-issues created"
    echo "  2. Run 'barf plan <sub-issue>' for each"
    echo "  3. Run 'barf build <sub-issue>' for each"
}

# ============================================================================
# Help & Version
# ============================================================================

show_help() {
    cat << 'EOF'
BARF - Build And Run Framework

Usage: barf <command> [options]

Commands:
  init                    Initialize BARF in current directory
  interview <issue>       Analyze issue and ask clarifying questions
  plan <issue> [max]      Generate implementation plan (max iterations)
  build <issue> [max]     Build from plan (max iterations)
  audit                   Perform codebase quality audit

Options:
  -h, --help              Show this help
  -v, --version           Show version

Examples:
  barf init
  barf interview auth
  barf plan auth 5
  barf build auth 20
  barf audit

Configuration:
  Create .barf.yaml in your project root to customize behavior.
  See .barf.yaml.example for all options.

For more information: https://github.com/brewpirate/barf
EOF
}

show_version() {
    echo "BARF v$VERSION"
}

# ============================================================================
# Main Entry Point
# ============================================================================

main() {
    local cmd="${1:-}"
    shift || true

    case "$cmd" in
        init)
            cmd_init "$@"
            ;;
        interview)
            cmd_interview "$@"
            ;;
        plan)
            cmd_plan "$@"
            ;;
        build)
            cmd_build "$@"
            ;;
        audit)
            cmd_audit "$@"
            ;;
        -h|--help|help)
            show_help
            ;;
        -v|--version|version)
            show_version
            ;;
        "")
            show_help
            ;;
        *)
            die "Unknown command: $cmd (use 'barf --help' for usage)"
            ;;
    esac
}

main "$@"
